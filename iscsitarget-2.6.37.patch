Index: iscsitarget-1.4.19/kernel/target.c
===================================================================
--- iscsitarget-1.4.19.orig/kernel/target.c	2009-09-28 21:08:20.000000000 +0200
+++ iscsitarget-1.4.19/kernel/target.c	2010-12-08 17:02:59.247843222 +0100
@@ -7,11 +7,12 @@
 #include "iscsi.h"
 #include "digest.h"
 #include "iscsi_dbg.h"
+#include <linux/semaphore.h>
 
 #define	MAX_NR_TARGETS	(1UL << 30)
 
 static LIST_HEAD(target_list);
-static DECLARE_MUTEX(target_list_sem);
+static DEFINE_SEMAPHORE(target_list_sem);
 static u32 next_target_id;
 static u32 nr_targets;
 
@@ -157,7 +158,7 @@ static int iscsi_target_create(struct ta
 
 	strncpy(target->name, name, sizeof(target->name) - 1);
 
-	init_MUTEX(&target->target_sem);
+	sema_init(&target->target_sem, 0);
 	spin_lock_init(&target->session_list_lock);
 
 	INIT_LIST_HEAD(&target->session_list);
--- trunk/kernel/config.c	2010/03/30 18:08:19	309
+++ trunk/kernel/config.c	2011/01/12 20:39:36	378
@@ -9,7 +9,7 @@
 #include "iscsi.h"
 #include "iscsi_dbg.h"
 
-static DECLARE_MUTEX(ioctl_sem);
+static DEFINE_MUTEX(ioctl_mutex);
 
 struct proc_entries {
 	const char *name;
@@ -258,7 +258,7 @@
 	long err;
 	u32 id;
 
-	err = down_interruptible(&ioctl_sem);
+	err = mutex_lock_interruptible(&ioctl_mutex);
 	if (err < 0)
 		return err;
 
@@ -339,7 +339,7 @@
 
 	target_unlock(target);
 done:
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return err;
 }
@@ -347,9 +347,9 @@
 static int release(struct inode *i __attribute__((unused)),
 		   struct file *f __attribute__((unused)))
 {
-	down(&ioctl_sem);
+	mutex_lock(&ioctl_mutex);
 	target_del_all();
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return 0;
 }
--- trunk/kernel/wthread.c	2010/04/11 15:34:14	320
+++ trunk/kernel/wthread.c	2011/01/19 18:36:01	389
@@ -67,14 +67,13 @@
 	struct iscsi_conn *conn;
 	DECLARE_WAITQUEUE(wait, current);
 
-	get_io_context(GFP_KERNEL, -1);
-
-	if (!current->io_context)
-		eprintk("%s\n", "Failed to get IO context");
-	else if (info->wthread_ioc)
-		copy_io_context(&current->io_context, &info->wthread_ioc);
-	else
-		info->wthread_ioc = current->io_context;
+	if (info->wthread_ioc &&
+	    atomic_long_inc_not_zero(&info->wthread_ioc->refcount)) {
+		put_io_context(current->io_context);
+		current->io_context = info->wthread_ioc;
+		atomic_inc(&info->wthread_ioc->nr_tasks);
+	} else
+		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
 
 	add_wait_queue(&info->wthread_sleep, &wait);
 
@@ -101,12 +100,14 @@
 	remove_wait_queue(&info->wthread_sleep, &wait);
 
 	if (current->io_context) {
-		struct io_context *ioc = current->io_context;
+		struct io_context *ioc;
 
 		task_lock(current);
+		ioc = current->io_context;
 		current->io_context = NULL;
 		task_unlock(current);
 
+		atomic_dec(&ioc->nr_tasks);
 		put_io_context(ioc);
 	}
 
